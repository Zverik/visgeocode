<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Visual Geocoding</title>
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css" />
<script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
<script src="Edit.SimpleShape.js"></script>
<script src="Edit.Rectangle.js"></script>
<script src="FunctionButton.js"></script>
<style>
html, body { height: 100%; }
#map { height: 400px; }
#meters { position: absolute; bottom: 10px; left: 10px; background: white; padding: 3px 6px; z-index: 999; font-size: 10px; display: none; }
#objdata { position: absolute; bottom: 35px; left: 10px; background: white; padding: 3px 6px; z-index: 999; display: none; }
</style>
</head>
<body>
<div id="form">
<div>Файл CSV с разделителями ";". Первая строка — заголовок, адрес в столбце «address» или «адрес», иначе он в первом столбце. Можно скопировать сюда собранный ранее GeoJSON.</div>
<textarea id="text" cols="80" rows="10">address;built
</textarea><br>
Город: <input type="text" id="city" size="60" value="Санкт-Петербург"><br>
<input type="button" value="Геокодировать" onclick="geocode();">
<p>Прямоугольник, в который попадают все точки из списка (не найденные точки будут у южной границы). После геокодирования двойной клик на рамку включает её редактирование, двойной клик на полученный из точки контур возвращает точку.</p>
</div>
<div id="map"></div>
<div id="meters"></div>
<div id="objdata"></div>

<script type="text/javascript">
var findbuildings = 'http://tile.osmz.ru/cgi-bin/findbuildings.py';
var bbox = '30,60.1,30.6,59.8'.split(/,/);

var map = L.map('map', {minZoom: 6}).setView([(+bbox[1] + (+bbox[3]))/2, (+bbox[0] + (+bbox[2]))/2], 8);
L.tileLayer('http://tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Карта &copy; <a href="https://openstreetmap.org">OpenStreetMap</a>' }).addTo(map);
var rect = L.rectangle([[bbox[3], bbox[0]], [bbox[1], bbox[2]]], { stroke: false });
map.addLayer(rect);
rect.editing.enable();

var toGeocode, bounds, failCoord, fcStep,
	cntTotal = 0, cntCorrect = 0, cntFailed = 0;

function geocode() {
	var text = $('#text').val();
	if( text.indexOf('"Feature"') > 0 ) {
		loadGeoJSON(text);
		return;
	}

	var i, j, tgc, line,
		csv = text.split(/\n/),
		fields = [],
		fieldAddr = 0;

	toGeocode = [];
	if (csv.length > 0) {
		fields = csv[0].split(/;/);
		for (i = 0; i < fields.length; i++)
			if (fields[i].toLowerCase() == 'addr' || fields[i].toLowerCase() == 'address' || fields[i].toLowerCase() == 'адрес')
				fieldAddr = i;
		for (i = 1; i < csv.length; i++) {
			line = csv[i].replace(/^\s+|\s+$/g, '').split(/;/);
			if( line.length > fieldAddr && line[fieldAddr].length > 0 ) {
				tgc = [ line[fieldAddr], {} ];
				for( j = 0; j < line.length; j++ )
					tgc[1][j < fields.length ? fields[j] : j] = line[j];
				toGeocode.push(tgc);
			}
		}
	}

	if (toGeocode.length > 0) {
		cntTotal = toGeocode.length;
		stageTwo();
		fcStep = (bounds.getEast() - bounds.getWest()) / 50;
		failCoord = L.latLng(bounds.getSouth() - fcStep * 2, bounds.getWest());
		geocodeLine(0);
	} else
		alert("No lines to geocode.");
}

function loadGeoJSON(geojson) {
	var data = {}, i, coord;
	try {
		data = JSON.parse(geojson);
	} catch(e) {}

	var features = 'features' in data ? data.features : L.Util.isArray(data) ? data : 'type' in data && data.type == 'Feature' ? [data] : [];
	for( i = 0; i < features.length; i++ ) {
		var f = features[i];
		if( 'type' in f && f.type == 'Feature' && 'geometry' in f && 'properties' in f ) {
			if( f.geometry.type == 'Point' ) {
				coord = L.GeoJSON.coordsToLatLng(f.geometry.coordinates);
				map.addLayer(createMarker(coord, f.properties));
				cntTotal++;
			} else if( f.geometry.type == 'Polygon' ) {
				map.addLayer(createPolygon(f.geometry, f.properties));
				cntTotal++;
			}
		}
	}
	if( features.length == 0 )
		alert('There are no features in this GeoJSON');
	else {
		stageTwo(true);
	}
}

function stageTwo(mapBounds) {
	rect.editing.disable();
	rect.setStyle({ stroke: true, fill: false });
	if( mapBounds ) {
		var b2, b3;
		map.eachLayer(function(layer) {
			if( 'extraData' in layer ) {
				b3 = layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds();
				if( !b2 )
					b2 = L.latLngBounds(b3);
				else
					b2.extend(b3);
			}
		});
		rect.setBounds(b2);
	}
	bounds = rect.getBounds();
	rect.on('dblclick', function() {
		if( rect.editing.enabled() )
			rect.editing.disable();
		else
			rect.editing.enable();
	});
	rect.on('edit', function() {
		bounds = rect.getBounds();
	});
	$('#form').hide();
	$('body').css('margin',0);
	$('#map').height('100%');
	$('#meters').show();
	map.invalidateSize();
	map.fitBounds(bounds);
	var btnDownload = { content: 'Скачать GeoJSON', callback: downloadGeoJSON};
	var btnPolygons = { content: 'Точки в контуры', callback: queryPolygons};
	map.addControl(L.functionButtons([btnDownload, btnPolygons], { position: 'topleft' }));
	updateCounts();
}

function geocodeLine(n) {
	if( n >= toGeocode.length )
		return;

	var addr = toGeocode[n][0],
		city = $('#city').val();

	tryGeocode('osmru', n, city + ' ' + addr, function(n) {
		addr = addr.replace(/\s*литер\s+[А-Я]+/i, '');
		addr = addr.replace(/Б\./, 'Большая ');
		addr = addr.replace(/М\./, 'Малая ');
		addr = addr.replace(/Кр\./, 'Красная ');
		addr = addr.replace(/проф\./, 'профессора ');
		addr = addr.replace(/ак\./, 'академика ');
		tryGeocode('osmru', n, city + ' ' + addr, function(n) {
			tryGeocode('osmru', n, addr, function(n) {
				tryGeocode('nominatim', n, addr + ', ' + city, function(n) {
					tryGeocode('sputnik', n, addr + ', ' + city, function(n) {
						// without housenumber
						addr = addr.replace(/\s*(?:д|дом)?\.?\s*\d.*$/, '');
						tryGeocode('osmru', n, city + ' ' + addr);
					});
				});
			});
		});
	});
}

function tryGeocode(engine, n, addr, next) {
	//console.log('Trying ' + engine + ' for line ' + n + ' addr: ' + addr);
	var server, params = { q: addr };
	if( engine == 'osmru' ) {
		server = 'http://openstreetmap.ru/api/search';
	} else if( engine == 'nominatim' ) {
		server = 'http://open.mapquestapi.com/nominatim/v1/search.php';
		params['format'] = 'json';
		params['viewbox'] = [bounds.getWest(), bounds.getNorth(), bounds.getEast(), bounds.getSouth()].join(',');
		params['bounded'] = 1;
	} else if( engine == 'sputnik' ) {
		server = 'http://search.maps.sputnik.ru/search';
		params['vlat'] = bounds.getCenter().lat;
		params['vlon'] = bounds.getCenter().lng;
	} else {
		//console.log('Unknown geocoding engine: ' + engine);
		return;
	}

	jQuery.ajax({
		url: server,
		data: params,
		//dataType: engine == 'sputnik' ? 'jsonp' : 'json'
		dataType: 'json'
	}).done(function(data) {
		process(data, n, next);
	}).fail(function() {
		process(false, n, next);
	});
}

function process(data, n, next) {
	//console.log(data); /* todo: remove */
	var list = !data ? [] : ('matches' in data ? data['matches'] : ('result' in data ? data['result'] : data));
	var i = 0, found = false;
	while( !found && i < list.length ) {
		var d = list[i++];
		var coord = 'position' in d && d['position'].length >= 2 ? d['position'] : d;
		if( 'lat' in coord && 'lon' in coord ) {
			coord = L.latLng(coord['lat'], coord['lon']);
			if( bounds.contains(coord) ) {
				found = coord;
			}
		}
	}
	if( !found && next )
		next(n);
	else {
		if( found ) {
			cntCorrect++;
		} else {
			cntFailed++;
		}
		map.addLayer(createMarker(found, toGeocode[n][1]));
		updateCounts();
		geocodeLine(n + 1);
	}
}

function createMarker(latLng, extraData) {
	var m;
	if( latLng )
		m = L.marker(latLng);
	else {
		m = L.marker(L.latLng(failCoord));
		failCoord.lng += fcStep;
		if( failCoord.lng >= bounds.getEast() ) {
			failCoord.lng = bounds.getWest();
			failCoord.lat += fcStep * 2;
		}
	}
	m.options.draggable = true;
	m.options.riseOnHover = true;
	m.on('mouseover click', function() {
		updateData(this);
	}, m);
	m.on('mouseout', function() {
		updateData();
	});
	m.extraData = extraData;
	return m;
}

function updateCounts() {
	var str = 'Всего: ' + cntTotal + ', найдено: ' + cntCorrect;
	if( cntFailed > 0 )
		str = str + ', мимо: ' + cntFailed;
	var cntPolygon = 0;
	map.eachLayer(function(layer) {
		if( 'extraData' in layer && 'oldMarker' in layer )
			cntPolygon++;
	});
	if( cntPolygon > 0 )
		str = str + ', контуров: ' + cntPolygon;
	$('#meters').html(str);
}

function updateData(obj) {
	var p, prop = [];
	if( obj && 'extraData' in obj ) {
		for( p in obj.extraData )
			if( obj.extraData.hasOwnProperty(p) )
				prop.push(p.replace(/&/, '&amp;').replace(/</, '&lt;') + ': ' + obj.extraData[p].replace(/&/, '&amp;').replace(/</, '&lt;'));
		$('#objdata').html(prop.join('<br>'));
		$('#objdata').show();
	} else
		$('#objdata').hide();
}

function downloadGeoJSON() {
	var f, features = [];
	map.eachLayer(function(layer) {
		if( 'extraData' in layer ) {
			f = { "type": "Feature", "properties": layer.extraData, "geometry": layer.toGeoJSON().geometry };
			features.push(f);
		}
	});
	var geojson = JSON.stringify({ "type": "FeatureCollection", "features": features });
	var w = window.open().document.write(geojson);
}

function queryPolygons() {
	var data = [], markerMap = {}, i = 0;
	map.eachLayer(function(layer) {
		if( layer instanceof L.Marker && 'extraData' in layer && bounds.contains(layer.getLatLng()) ) {
			markerMap[i] = layer;
			data.push({ "id": i, "lat": layer.getLatLng().lat, "lon": layer.getLatLng().lng });
			i++;
		}
	});
	if( data.length > 0 ) {
		jQuery.ajax({
			url: findbuildings,
			type: 'POST',
			data: { 'json': JSON.stringify(data) },
			dataType: 'json'
		}).done(function(data) {
			for( i = 0; i < data.length; i++ ) {
				if( 'id' in data[i] && 'geometry' in data[i] ) {
					var marker = markerMap[data[i]['id']];
					var layer = createPolygon(data[i]['geometry'], marker.extraData, marker);
					map.removeLayer(marker);
					map.addLayer(layer);
				}
			}
			updateCounts();
		}).fail(function() {
			alert("Failed to request data");
		});
	}
}

function createPolygon(geometry, extraData, marker) {
	var layer = L.GeoJSON.geometryToLayer(geometry);
	layer.oldMarker = marker;
	layer.extraData = extraData;
	layer.on('mouseover click', function() {
		updateData(this);
	}, layer);
	layer.on('mouseout', function() {
		updateData();
	});
	layer.on('dblclick', function() {
		var m = this.oldMarker || createMarker(layer.getBounds().getCenter(), extraData);
		map.addLayer(m);
		map.removeLayer(this);
	}, layer);
	return layer;
}
</script>
</body>
</html>
